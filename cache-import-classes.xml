<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25" zv="Cache for Windows (x86-64) 2017.1.1 (Build 111U)" ts="2017-07-21 16:58:14">
<Class name="%Zcas.Redirect">
<Super>%RegisteredObject</Super>
<TimeChanged>64482,47057.508395</TimeChanged>
<TimeCreated>64461,82515.693398</TimeCreated>

<Method name="run">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[className:%String,method:%String,&sts,arguments...]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	s io=$io
	s %Stream=##class(%Stream.TmpCharacter).%New()
	u io::("^"_$zname)
	d ##class(%Library.Device).ReDirectIO(1)
	
	i (sts=1) {
		s sts=$CLASSMETHOD(className, method, arguments...)
	} else {
		d $CLASSMETHOD(className, method, arguments...)
	}
	
	d ##class(%Library.Device).ReDirectIO(0)
	u io
	
	d %Stream.Rewind()
	
	s result=""
	d {
		s dat=%Stream.Read(.len) q:len<0
		s result=result_dat
	} while(len>0)
	
	q result
]]></Implementation>
</Method>

<Method name="runObj">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[obj:%ObjectHandle,method:%String,&sts,arguments...]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	s io=$io
	s %Stream=##class(%Stream.TmpCharacter).%New()
	u io::("^"_$zname)
	d ##class(%Library.Device).ReDirectIO(1)
	
	i (sts=1) {
		s sts=$METHOD(obj, method, arguments...)
	} else {
		d $METHOD(obj, method, arguments...)
	}
	
	d ##class(%Library.Device).ReDirectIO(0)
	u io
	
	d %Stream.Rewind()
	
	s result=""
	d {
		s dat=%Stream.Read(.len) q:len<0
		s result=result_dat
	} while(len>0)
	
	q result
]]></Implementation>
</Method>

<Method name="redirects">
<ClassMethod>1</ClassMethod>
<ProcedureBlock>0</ProcedureBlock>
<Implementation><![CDATA[
#; Public entry points for redirection
rstr(len,time)  Quit ""
rchr(time)      Quit ""
wstr(s) Do %Stream.Write(s) Quit
wchr(a) Do %Stream.Write($char(a)) Quit
wnl Do %Stream.Write($char(13,10)) Quit
wff Do %Stream.Write($char(13,10,13,10)) Quit
wtab(n) New chars Set $piece(chars," ",n+1)="" Do %Stream.Write(chars) Quit
]]></Implementation>
</Method>
</Class>


<Class name="cas.func.Common">
<Description><![CDATA[
<b> Cache Atom Studio - Commands </b> : 2017/06/17 : Akio Hashimoto.<br>
<br>]]></Description>
<IncludeCode>%sySystem,%occFile</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeChanged>64485,60641.947973</TimeChanged>
<TimeCreated>64451,6886.500997</TimeCreated>

<Method name="createDirectory">
<ClassMethod>1</ClassMethod>
<FormalSpec>path:%Status</FormalSpec>
<Implementation><![CDATA[
	i ('##class(%File).DirectoryExists(path)) {
		d ##class(%File).CreateDirectoryChain(path)
	}
	q
]]></Implementation>
</Method>

<Method name="import">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[ns:%String,files:%String,sub:%Boolean=0,compile:%String="",&targetList:%String="",*log:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	s result=$$$OK
	try {
		new $namespace
		s $namespace=ns
		
		i ('$lv(files)) {
			s files=$lb(files)
		}
		
		f p=1:1:$ll(files) {
			s file=$li(files, p)
			i (##class(%File).DirectoryExists(file)) {
				s wlist=""
				s rs=##class(%ResultSet).%New("%File:FileSet")
				s r=rs.Execute(file, "*", "", 1)
				while(rs.Next()) {
					s name=rs.Data("Name")
					s type=rs.Data("Type")
					s item=rs.Data("ItemName")
					continue:$e(item, 1, 1)="."
					i (type="D") {
						i (sub) {
							s r=..import(ns, name, sub, "", .targetList)
						}
					} else {
						s wlist=wlist_$lb(name)
					}
				}
				i (wlist'="") {
					s r=..import(ns, wlist, sub, "", .targetList)
				}
			} elseif (##class(%File).Exists(file)) {
				s ex=$zcvt($p(file, ".", *), "l")
				i (ex="cls") {
					s text="", item=""
					s ff=##class(%Stream.FileCharacter).%New()
					s r=ff.LinkToFile(file)
					s ff.TranslateTable="UTF8"
					
					while('ff.AtEnd) {
						s text=text_ff.Read()
					}
					
					f c=1:1:$l(text, ff.LineTerminator) {
						s dat=$p(text, ff.LineTerminator, c)
						i ($e(dat, 1, $l("Class "))="Class ") {
							s item=$p(dat, " ", 2)
						}
					}
					i (item'="") {
						s r=..updateClass(ns, item, text, 1)
					}
					s targetList(item)=""
				} elseif ((ex="inc")!(ex="mac")!(ex="int")) {
					s text=""
					s ff=##class(%Stream.FileCharacter).%New()
					s r=ff.LinkToFile(file)
					s ff.TranslateTable="UTF8"
					s item=##class(%File).GetFilename(file)
					
					while('ff.AtEnd) {
						s text=text_ff.Read()
					}
					
					s r=..updateRoutine(ns, item, text, 1)
					
					s targetList(item)=""
				}
			}
		}
		
		i (compile'="") {
			// ex. compile="cuk"
			
			i ($d(targetList)) {
				s pjName="cosAtomProject"
				s pj=##class(%Studio.Project).%New()
				s pj.Name=pjName
				
				s name="", p=1
				f {
					s name=$o(targetList(name)) q:name=""
					s r=pj.AddItem(name), p=p+1
				}
				s c=pj.%Save(),c=pj.%Close() k pj
				
				i (p>0) {
					s sts=1
					s clog=##class(%Zcas.Redirect).run("%SYSTEM.OBJ", "CompileProject", .sts, pjName, compile, .err)
					$$$THROWONERROR(r, sts)
					
					s clog=$tr($zstrip(clog, "<>w", $c(13,10)), $c(13), "")
					f p=1:1:$l(clog, $c(10)) {
						s log($i(log))=$p(clog, $c(10), p)
					}
				}
				$$$THROWONERROR(r, $System.OBJ.DeleteProject(pjName))
			}
		}
	} catch e {
		s result=e.AsStatus()
	}
	q result
]]></Implementation>
</Method>

<Method name="updateClass">
<ClassMethod>1</ClassMethod>
<FormalSpec>ns:%String,className:%String,text:%String,notcvt:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	s result=$$$OK
	try {
		new $namespace
		s $namespace=ns
		
		i ($e($zcvt(className, "l"), *-3, *)=".cls") {
			s className=$e(className, 1, *-4)
		}
		
		s st=##class(%Dictionary.ClassDefinition).%ExistsId(className)
		i ('st) {
			s nc = ##class(%Dictionary.ClassDefinition).%New(className)
			s nc.Super = ""
			s nc.Abstract = ""
			s st=nc.%Save()
		}
		
		s stream=##class(%Stream.GlobalCharacter).%New()
		d stream.Write($s(notcvt:text, 1:$zcvt(text,"I","UTF8")))
		$$$THROWONERROR(r, ##class(%Compiler.UDL.TextServices).SetTextFromStream(ns, className, stream))
	} catch e {
		s result=e.AsStatus()
	}
	q result
]]></Implementation>
</Method>

<Method name="updateRoutine">
<ClassMethod>1</ClassMethod>
<FormalSpec>ns:%String,routineName:%String,text:%String,notcvt:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	s result=$$$OK
	try {
		new $namespace
		s $namespace=ns
		
		s st=##class(%Routine).Exists(routineName)
		i ('st) {
			s routine=##class(%Routine).%New(routineName)
		} else {
			s routine=##class(%Routine).%OpenId(routineName)
		}
		
		s stream=##class(%Stream.GlobalCharacter).%New()
		d stream.Write($s(notcvt:text, 1:$zcvt(text,"I","UTF8")))
		$$$THROWONERROR(r, routine.CopyFromAndSave(stream))
	} catch e {
		s result=e.AsStatus()
	}
	q result
]]></Implementation>
</Method>

<Method name="compileClass">
<ClassMethod>1</ClassMethod>
<FormalSpec>ns:%String,className:%String,*log:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	s result=$$$OK
	try {
		new $namespace
		s $namespace=ns
		
		i ($e($zcvt(className, "l"), *-3, *)=".cls") {
			s className=$e(className, 1, *-4)
		}
		
		q:'##class(%Dictionary.ClassDefinition).%ExistsId(className)
		
		s sts=1
		s clog=##class(%Zcas.Redirect).run("%SYSTEM.OBJ", "Compile", .sts, className, "cuk", .err)
		$$$THROWONERROR(r, sts)
		
		s clog=$tr($zstrip(clog, "<>w", $c(13,10)), $c(13), "")
		f p=1:1:$l(clog, $c(10)) {
			s log($i(log))=$p(clog, $c(10), p)
		}
	} catch e {
		s result=e.AsStatus()
	}
	q result
]]></Implementation>
</Method>

<Method name="compileRoutine">
<ClassMethod>1</ClassMethod>
<FormalSpec>ns:%String,routineName:%String,*log:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	s result=$$$OK
	try {
		new $namespace
		s $namespace=ns
		
		q:'##class(%Routine).Exists(routineName)
		
		s routine=##class(%RoutineMgr).%OpenId(routineName)
		i ($e($zcvt(routineName, "l"), *-3, *)'=".inc") {
			s sts=1
			s clog=##class(%Zcas.Redirect).runObj(routine, "Compile", .sts, "cuk")
			$$$THROWONERROR(r, sts)
			
			s clog=$tr($zstrip(clog, "<>w", $c(13,10)), $c(13), "")
			f p=1:1:$l(clog, $c(10)) {
				s log($i(log))=$p(clog, $c(10), p)
			}
		}
	} catch e {
		s result=e.AsStatus()
	}
	q result
]]></Implementation>
</Method>

<Method name="compileAll">
<ClassMethod>1</ClassMethod>
<FormalSpec>ns:%String,*log:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	s result=$$$OK
	try {
		new $namespace
		s $namespace=ns
		
		k list
		
		s rs=##class(%ResultSet).%New("%ClassDefinition:ClassInfo")
		$$$THROWONERROR(r, rs.Execute("", 0))
		
		d {
			s a=rs.Next(.ec)
			$$$THROWONERROR(ec, ec)
			i (a) {
				continue:rs.Get("System")=4
				
				s clsName=rs.Get("Name")
				continue:$e(clsName, 1, 1)="%"
				
				s list(clsName_".cls")=""
			}
		} while(a)
		
		s rs=##class(%ResultSet).%New("%Library.Routine:RoutineList")
		$$$THROWONERROR(r, rs.Execute("", 1, 0, ns))
		
		s routines=""
		d {
			s a=rs.Next(.ec)
			$$$THROWONERROR(ec, ec)
			i (a) {
				s rtnName=rs.Get("Name")
				continue:$e(rtnName, 1, 1)="%"
				continue:$match(rtnName, "(?i).*\.\d+\.INT$")
				continue:$match(rtnName, "(?i).*\.[A-Z]?\d+\.MAC$")
				
				s rtn=##class(%Routine).%OpenId(rtnName)
				i ('rtn.Generated) {
					s list(rtnName)=""
				}
			}
		} while(a)
		
		s pjName="cosAtomProject"
		s pj=##class(%Studio.Project).%New()
		s pj.Name=pjName
		
		s name="", p=1
		f {
			s name=$o(list(name)) q:name=""
			s r=pj.AddItem(name), p=p+1
		}
		s c=pj.%Save(),c=pj.%Close() k pj
		
		i (p>0) {
			s sts=1
			s clog=##class(%Zcas.Redirect).run("%SYSTEM.OBJ", "CompileProject", .sts, pjName, "cuk", .err)
			$$$THROWONERROR(r, sts)
			
			s clog=$tr($zstrip(clog, "<>w", $c(13,10)), $c(13), "")
			f p=1:1:$l(clog, $c(10)) {
				s log($i(log))=$p(clog, $c(10), p)
			}
		}
		$$$THROWONERROR(r, $System.OBJ.DeleteProject(pjName))
	} catch e {
		s result=e.AsStatus()
	}
	q result
]]></Implementation>
</Method>

<Method name="deleteClass">
<ClassMethod>1</ClassMethod>
<FormalSpec>ns:%String,className:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	s result=$$$OK
	try {
		new $namespace
		s $namespace=ns
		
		i ($e($zcvt(className, "l"), *-3, *)=".cls") {
			s className=$e(className, 1, *-4)
		}
		
		q:'##class(%Dictionary.ClassDefinition).%ExistsId(className)
		
		$$$THROWONERROR(r, $System.OBJ.Delete(className, "e-d", .err))
	} catch e {
		s result=e.AsStatus()
	}
	q result
]]></Implementation>
</Method>

<Method name="deleteRoutine">
<ClassMethod>1</ClassMethod>
<FormalSpec>ns:%String,routineName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	s result=$$$OK
	try {
		new $namespace
		s $namespace=ns
		
		q:'##class(%Routine).Exists(routineName)
		
		$$$THROWONERROR(r, ##class(%Routine).Delete(routineName, 0, 0, ns))
	} catch e {
		s result=e.AsStatus()
	}
	q result
]]></Implementation>
</Method>

<Method name="exportClass">
<ClassMethod>1</ClassMethod>
<FormalSpec>ns:%String,path:%String,className</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	s result=$$$OK
	try {
		new $namespace
		s $namespace=ns
		
		s path=$tr(path, "\", "/")
		s path=$s($e(path, *)="/":$e(path, 1, *-1), 1:path)
		
		i ($e($zcvt(className, "l"), *-3, *)=".cls") {
			s className=$e(className, 1, *-4)
		}
		
		s wpath=path_"/Class/"
		s list=$lfs(className, ".")
		f i=1:1:$ll(list)-1 {
			s wpath=wpath_$li(list, i)_"/"
		}
		d ..createDirectory(wpath)
		
		s r=##class(%Compiler.UDL.TextServices).GetTextAsStream(ns, className, .tStream)
		s file=##class(%Stream.FileBinary).%New()
		s wfile=wpath_$li(list, *)_".cls"
		s file.Filename=wfile
		s r=file.Write($zcvt(tStream.Read(tStream.Size), "O", "UTF8"))
		s r=file.%Save()
		k file
		i ($$$ISWINDOWS) {
		} else {
			d $zf(-1, "chmod 777 "_wfile)
		}
	} catch e {
		s result=e.AsStatus()
	}
	q result
]]></Implementation>
</Method>

<Method name="exportRoutine">
<ClassMethod>1</ClassMethod>
<FormalSpec>ns:%String,path:%String,routineName</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	s result=$$$OK
	try {
		new $namespace
		s $namespace=ns
		
		s path=$tr(path, "\", "/")
		s path=$s($e(path, *)="/":$e(path, 1, *-1), 1:path)
		
		s wpath=path_"/Routine/"
		d ..createDirectory(wpath)
		
		s rtn=##class(%Routine).%OpenId(routineName)
		i ('rtn.Generated) {
			s list=$lfs(routineName, ".")
			
			s file=##class(%Stream.FileBinary).%New()
			s wfile=wpath_$lts($li(list,1,*-1),".")_"."_$zcvt($li(list, *), "l")
			s file.Filename=wfile
			//s r=file.CopyFrom(rtn)
			s r=file.Write($zcvt(rtn.Read(rtn.Size), "O", "UTF8"))
			s r=file.%Save()
			k file
			i ($$$ISWINDOWS) {
			} else {
				d $zf(-1, "chmod 777 "_wfile)
			}
		}
	} catch e {
		s result=e.AsStatus()
	}
	q result
]]></Implementation>
</Method>

<Method name="exportClassFiles">
<ClassMethod>1</ClassMethod>
<FormalSpec>ns:%String,path:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	s result=$$$OK
	try {
		new $namespace
		s $namespace=ns
		
		s path=$tr(path, "\", "/")
		s path=$s($e(path, *)="/":$e(path, 1, *-1), 1:path)
		
		s rs=##class(%ResultSet).%New("%ClassDefinition:ClassInfo")
		$$$THROWONERROR(r, rs.Execute("", 0))
		
		d {
			s a=rs.Next(.ec)
			$$$THROWONERROR(ec, ec)
			i (a) {
				continue:rs.Get("System")=4
				
				s clsName=rs.Get("Name")
				i ($e(clsName, 1, 1)="%") {
					continue:$e(clsName, 1, 2)'="%Z"
				}
				
				s wpath=path_"/Class/"
				s list=$lfs(clsName, ".")
				f i=1:1:$ll(list)-1 {
					s wpath=wpath_$li(list, i)_"/"
				}
				d ..createDirectory(wpath)
				
				s r=##class(%Compiler.UDL.TextServices).GetTextAsStream(ns, clsName, .tStream)
				s file=##class(%Stream.FileBinary).%New()
				s wfile=wpath_$li(list, *)_".cls"
				s file.Filename=wfile
				s r=file.Write($zcvt(tStream.Read(tStream.Size), "O", "UTF8"))
				s r=file.%Save()
				k file
				i ($$$ISWINDOWS) {
				} else {
					d $zf(-1, "chmod 777 "_wfile)
				}
			}
		} while(a)
	} catch e {
		s result=e.AsStatus()
	}
	q result
]]></Implementation>
</Method>

<Method name="exportRoutineFiles">
<ClassMethod>1</ClassMethod>
<FormalSpec>ns:%String,path:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	s result=$$$OK
	try {
		new $namespace
		s $namespace=ns
		
		s dest=##class(%SYS.Namespace).GetRoutineDest()
		
		s path=$tr(path, "\", "/")
		s path=$s($e(path, *)="/":$e(path, 1, *-1), 1:path)
		
		s wpath=path_"/Routine/"
		d ..createDirectory(wpath)
		
		s rs=##class(%ResultSet).%New("%Library.Routine:RoutineList")
		$$$THROWONERROR(r, rs.Execute("", 1, 0, ns))
		
		s routines=""
		d {
			s a=rs.Next(.ec)
			$$$THROWONERROR(ec, ec)
			i (a) {
				s rtnName=rs.Get("Name")
				i ($e(rtnName, 1, 1)="%") {
					continue:$e(rtnName, 1, 2)'="%Z"
				}
				continue:$match(rtnName, "(?i).*\.\d+\.INT$")
				continue:$match(rtnName, "(?i).*\.[A-Z]?\d+\.MAC$")
				
				s wdest=##class(%SYS.Namespace).GetRoutineDest(, rtnName)
				continue:dest'=wdest
				
				s rtn=##class(%Routine).%OpenId(rtnName)
				i ('rtn.Generated) {
					s list=$lfs(rtnName, ".")
					
					s file=##class(%Stream.FileBinary).%New()
					s wfile=wpath_$lts($li(list,1,*-1),".")_"."_$zcvt($li(list, *), "l")
					s file.Filename=wfile
					//s r=file.CopyFrom(rtn)
					s r=file.Write($zcvt(rtn.Read(rtn.Size), "O", "UTF8"))
					s r=file.%Save()
					k file
					i ($$$ISWINDOWS) {
					} else {
						d $zf(-1, "chmod 777 "_wfile)
					}
				}
			}
		} while(a)
	} catch e {
		s result=e.AsStatus()
	}
	q result
]]></Implementation>
</Method>

<Method name="command">
<ClassMethod>1</ClassMethod>
<FormalSpec>ns:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	s result=$$$OK
	try {
		new $namespace
		s $namespace=ns
		
		s cmd="s r=$System.OBJ.Compile(""User.NewClass1"", ""cuk"", .err)"
		s device="|TRM|",od=$io
		o device:(cmd:"QR"):100 i '$t ztrap
		u device
		
		s eof=$zu(68,40,1),flg=0
		f j=1:1 {
			q:flg
			
			r line:10 i '$t s flg=1 s line="ERR::Read Timeout."
			s flg=$zeof
			
			u od
			s lines($i(lines))=line
			u device
		}
		s eof=$zu(68,40,eof)
		c device
		u od
		
		m ^Ah(2)=lines
	} catch e {
		s result=e.AsStatus()
	}
	q result
]]></Implementation>
</Method>
</Class>


<Class name="cas.service.webapi.Broker">
<Description><![CDATA[
<b> Cache Atom Studio - WebApi </b> : 2017/06/17 : Akio Hashimoto.<br>
<br>]]></Description>
<Super>%CSP.REST</Super>
<TimeChanged>64478,62692.559639</TimeChanged>
<TimeCreated>64443,65296.487902</TimeCreated>

<Parameter name="CHARSET">
<Default>UTF-8</Default>
</Parameter>

<Parameter name="CONVERTINPUTSTREAM">
<Default>1</Default>
</Parameter>

<Parameter name="UseSession">
<Default>1</Default>
</Parameter>

<Parameter name="GZIPOUTPUT">
<Default>1</Default>
</Parameter>

<XData name="UrlMap">
<Data><![CDATA[
<Routes>
<Route Url="/start/" Method="POST" Call="start" />
<Route Url="/end/" Method="POST" Call="end" />
<Route Url="/update/" Method="POST" Call="update" />
<Route Url="/compile/" Method="POST" Call="compile" />
<Route Url="/compile-all/" Method="POST" Call="compileAll" />
<Route Url="/delete/" Method="POST" Call="delete" />
<Route Url="/export-all/" Method="POST" Call="exportAll" />
</Routes>
]]></Data>
</XData>

<Method name="start">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	s json={
		"CSPSessionCookie":(%session.CSPSessionCookie)
	}
	s %response.ContentType="application/json; charset=utf-8"
	w json.%ToJSON()
	q $$$OK
]]></Implementation>
</Method>

<Method name="end">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	s %session.EndSession=1
	q $$$OK
]]></Implementation>
</Method>

<Method name="update">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	s result=$$$OK
	s obj=##class(%Library.DynamicObject).%FromJSON(%request.Content) 
	s xjson=$zconvert(obj.%ToJSON(), "o", "UTF8"), json=##class(%Library.DynamicObject).%FromJSON(xjson) k obj
	try {
		s clog=[]
		i ($e($zcvt(json.sourceName, "l"), *-3, *)=".cls") {
			$$$THROWONERROR(r, ##class(cas.func.Common).updateClass(json.namespace, json.sourceName, json.source))
			$$$THROWONERROR(r, ##class(cas.func.Common).compileClass(json.namespace, json.sourceName, .log))
			$$$THROWONERROR(r, ##class(cas.func.Common).exportClass(json.namespace, json.directory, json.sourceName))
		} else {
			$$$THROWONERROR(r, ##class(cas.func.Common).updateRoutine(json.namespace, json.sourceName, json.source))
			$$$THROWONERROR(r, ##class(cas.func.Common).compileRoutine(json.namespace, json.sourceName, .log))
			$$$THROWONERROR(r, ##class(cas.func.Common).exportRoutine(json.namespace, json.directory, json.sourceName))
		}
		s p=""
		f {
			s p=$o(log(p), 1, dat) q:p=""
			d clog.%Push(dat)
		}
		
		s res={
			"status":"1",
			"message":["Saving of source is complete."],
			"log":(clog)
		}
		s %response.NoCharSetConvert=1
		w $zcvt(res.%ToJSON(), "o", "UTF8")
	} catch e {
		s result=e.AsStatus()
	}
	q result
]]></Implementation>
</Method>

<Method name="compile">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	s result=$$$OK
	s obj=##class(%Library.DynamicObject).%FromJSON(%request.Content) 
	s xjson=$zconvert(obj.%ToJSON(), "o", "UTF8"), json=##class(%Library.DynamicObject).%FromJSON(xjson) k obj
	try {
		s clog=[]
		s classes = json.list.%GetIterator()
		while classes.%GetNext(.key , .sourceName ) {
			i ($e($zcvt(sourceName, "l"), *-3, *)=".cls") {
				$$$THROWONERROR(r, ##class(cas.func.Common).compileClass(json.namespace, sourceName, .log))
				s p=""
				f {
					s p=$o(log(p), 1, dat) q:p=""
					d clog.%Push(dat)
				}
				$$$THROWONERROR(r, ##class(cas.func.Common).exportClass(json.namespace, json.directory, sourceName))
			} else {
				$$$THROWONERROR(r, ##class(cas.func.Common).compileRoutine(json.namespace, sourceName, .log))
				s p=""
				f {
					s p=$o(log(p), 1, dat) q:p=""
					d clog.%Push(dat)
				}
				$$$THROWONERROR(r, ##class(cas.func.Common).exportRoutine(json.namespace, json.directory, sourceName))
			}
		}
		
		s res={
			"status":"1",
			"message":"",
			"log":(clog)
		}
		s %response.ContentType="application/json; charset=utf-8"
		w res.%ToJSON()
	} catch e {
		s result=e.AsStatus()
	}
	q result
]]></Implementation>
</Method>

<Method name="compileAll">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	s result=$$$OK
	s obj=##class(%Library.DynamicObject).%FromJSON(%request.Content) 
	s xjson=$zconvert(obj.%ToJSON(), "o", "UTF8"), json=##class(%Library.DynamicObject).%FromJSON(xjson) k obj
	try {
		s clog=[]
		$$$THROWONERROR(r, ##class(cas.func.Common).compileAll(json.namespace, .log))
		s p=""
		f {
			s p=$o(log(p), 1, dat) q:p=""
			d clog.%Push(dat)
		}
		$$$THROWONERROR(r, ##class(cas.func.Common).exportClassFiles(json.namespace, json.directory))
		$$$THROWONERROR(r, ##class(cas.func.Common).exportRoutineFiles(json.namespace, json.directory))
		
		s res={
			"status":"1",
			"message":"",
			"log":(clog)
		}
		s %response.ContentType="application/json; charset=utf-8"
		w res.%ToJSON()
	} catch e {
		s result=e.AsStatus()
	}
	q result
]]></Implementation>
</Method>

<Method name="delete">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	s result=$$$OK
	s obj=##class(%Library.DynamicObject).%FromJSON(%request.Content) 
	s xjson=$zconvert(obj.%ToJSON(), "o", "UTF8"), json=##class(%Library.DynamicObject).%FromJSON(xjson) k obj
	try {
		s classes = json.list.%GetIterator()
		while classes.%GetNext(.key , .sourceName ) {
			i ($e($zcvt(sourceName, "l"), *-3, *)=".cls") {
				$$$THROWONERROR(r, ##class(cas.func.Common).deleteClass(json.namespace, sourceName))
			} else {
				$$$THROWONERROR(r, ##class(cas.func.Common).deleteRoutine(json.namespace, sourceName))
			}
		}
		
		s res={
			"status":"1",
			"message":"Source has been deleted."
		}
		s %response.ContentType="application/json; charset=utf-8"
		w res.%ToJSON()
	} catch e {
		s result=e.AsStatus()
	}
	q result
]]></Implementation>
</Method>

<Method name="exportAll">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	s result=$$$OK
	s obj=##class(%Library.DynamicObject).%FromJSON(%request.Content) 
	s xjson=$zconvert(obj.%ToJSON(), "o", "UTF8"), json=##class(%Library.DynamicObject).%FromJSON(xjson) k obj
	try {
		$$$THROWONERROR(r, ##class(cas.func.Common).exportClassFiles(json.namespace, json.directory))
		$$$THROWONERROR(r, ##class(cas.func.Common).exportRoutineFiles(json.namespace, json.directory))
		
		s res={
			"status":"1",
			"message":["Export completed."]
		}
		s %response.ContentType="application/json; charset=utf-8"
		w res.%ToJSON()
	} catch e {
		s result=e.AsStatus()
	}
	q result
]]></Implementation>
</Method>
</Class>
</Export>
